<!DOCTYPE html>
<html lang="pt-BR">
<head>
Â  <meta charset="UTF-8" />
Â  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
Â  <title>Redirecionando...</title>
Â Â 
Â  Â  Â  <script>
Â  !function(f,b,e,v,n,t,s){if(f.fbq)return;n=f.fbq=function(){
Â  n.callMethod? n.callMethod.apply(n,arguments):n.queue.push(arguments)};
Â  if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
Â  n.queue=[];t=b.createElement(e);t.async=!0;
Â  t.src=v;s=b.getElementsByTagName(e)[0];
Â  s.parentNode.insertBefore(t,s)}(window, document,'script',
Â  'https://connect.facebook.net/en_US/fbevents.js');
Â  </script>
Â  <noscript>
Â  Â  <img height="1" width="1" style="display:none"
Â  Â  Â  Â  Â src="https://www.facebook.com/tr?id=1465089154541888&ev=PageView&noscript=1"/>
Â  </noscript>

Â  <style>
Â  Â  body {
Â  Â  Â  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
Â  Â  Â  text-align: center;
Â  Â  Â  margin: 0;
Â  Â  Â  padding: 0;
Â  Â  Â  min-height: 100vh;
Â  Â  Â  display: flex;
Â  Â  Â  flex-direction: column;
Â  Â  Â  justify-content: center;
Â  Â  Â  align-items: center;
Â  Â  Â  background: #ffffff;
Â  Â  Â  color: #1a5f7a;
Â  Â  Â  cursor: pointer;
Â  Â  Â  user-select: none;
Â  Â  }
Â  Â Â 
Â  Â  .main-message {
Â  Â  Â  font-size: 20px;
Â  Â  Â  font-weight: 500;
Â  Â  Â  margin: 0;
Â  Â  Â  padding: 20px;
Â  Â  Â  text-align: center;
Â  Â  Â  max-width: 500px;
Â  Â  Â  line-height: 1.4;
Â  Â  Â  color: #1a5f7a;
Â  Â  }
Â  Â Â 
Â  Â  .loading-indicator {
Â  Â  Â  display: flex;
Â  Â  Â  align-items: center;
Â  Â  Â  justify-content: center;
Â  Â  Â  margin-bottom: 20px;
Â  Â  }
Â  Â Â 
Â  Â  .loading-dot {
Â  Â  Â  width: 8px;
Â  Â  Â  height: 8px;
Â  Â  Â  border-radius: 50%;
Â  Â  Â  background-color: #00d4aa;
Â  Â  Â  margin: 0 4px;
Â  Â  Â  animation: pulse 1.5s ease-in-out infinite;
Â  Â  }
Â  Â Â 
Â  Â  .loading-dot:nth-child(2) {
Â  Â  Â  animation-delay: 0.2s;
Â  Â  }
Â  Â Â 
Â  Â  .loading-dot:nth-child(3) {
Â  Â  Â  animation-delay: 0.4s;
Â  Â  }
Â  Â Â 
Â  Â  @keyframes pulse {
Â  Â  Â  0%, 60%, 100% {
Â  Â  Â  Â  opacity: 0.3;
Â  Â  Â  Â  transform: scale(0.8);
Â  Â  Â  }
Â  Â  Â  30% {
Â  Â  Â  Â  opacity: 1;
Â  Â  Â  Â  transform: scale(1);
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  .redirect-text {
Â  Â  Â  font-size: 24px;
Â  Â  Â  font-weight: 600;
Â  Â  Â  color: #1a5f7a;
Â  Â  Â  margin-top: 30px;
Â  Â  }
Â  Â Â 
Â  Â  .click-hint {
Â  Â  Â  font-size: 14px;
Â  Â  Â  color: #7a9ca8;
Â  Â  Â  margin-top: 20px;
Â  Â  Â  font-weight: 400;
Â  Â  Â  opacity: 0.8;
Â  Â  }
Â  </style>
</head>
<body>
Â  <div class="main-message">
Â  Â  <div class="loading-indicator">
Â  Â  Â  <div class="loading-dot"></div>
Â  Â  Â  <div class="loading-dot"></div>
Â  Â  Â  <div class="loading-dot"></div>
Â  Â  </div>
Â  Â  Estamos redirecionando para o Whatsapp
Â  </div>
Â Â 
Â  <div class="redirect-text">
Â  Â  Aguarde um instante...
Â  </div>
Â Â 
Â  <div class="click-hint">
Â  Â  Isso leva sÃ³ alguns segundos
Â  </div>

Â  <script>
Â  Â  // ============== REDIRECT FUNCTIONS ======================
Â  Â  let redirectInProgress = false;
Â  Â Â 
Â  Â  // FunÃ§Ã£o para redirecionar para WhatsApp
Â  Â  async function redirectToWhatsApp() {
Â  Â  Â  if (redirectInProgress) return; // Evita mÃºltiplos redirects
Â  Â  Â Â 
Â  Â  Â  redirectInProgress = true;
Â  Â  Â  console.log('ğŸ”„ Redirecionamento manual ativado!');
Â  Â  Â Â 
Â  Â  Â  // Cria a mensagem com token visÃ­vel como "Cupom: {token}"
      // NOTA: A mensagem aqui serÃ¡ diferente da usada no redirect automÃ¡tico.
      // Isso Ã© aceitÃ¡vel, pois o evento de Lead principal jÃ¡ foi disparado com o token correto.
Â  Â  Â  const event_id = uuidv4();
Â  Â  Â  const tokenHex = event_id.replace(/-/g,'').slice(0,8);
Â  Â  Â  const mensagem = `${BASE_MESSAGE}${tokenHex}`;
Â  Â  Â Â 
Â  Â  Â  // âš ï¸ REMOVIDO: Webhook manual para evitar duplicaÃ§Ã£o
Â  Â  Â  console.log('ğŸ“¤ Webhook jÃ¡ enviado automaticamente, pulando envio manual...');
Â  Â  Â Â 
      // ===================================================================
      // âš ï¸ ALTERAÃ‡ÃƒO DE MELHORIA: Bloco de disparo do Pixel de Lead manual removido para evitar duplicaÃ§Ã£o.
      // O evento de Lead agora Ã© disparado de forma confiÃ¡vel apenas uma vez, no carregamento da pÃ¡gina.
      // ===================================================================
Â  Â  Â  /*
      try {
Â  Â  Â  Â  if (fbq) {
Â  Â  Â  Â  Â  const pixelPayload = {
Â  Â  Â  Â  Â  Â  value: 0,
Â  Â  Â  Â  Â  Â  currency: 'BRL',
Â  Â  Â  Â  Â  Â  content_name: 'WhatsApp Lead Manual',
Â  Â  Â  Â  Â  Â  content_category: 'Lead Generation',
Â  Â  Â  Â  Â  Â  content_type: 'product',
Â  Â  Â  Â  Â  Â  lead_type: 'whatsapp_redirect_manual',
Â  Â  Â  Â  Â  Â  lead_source: 'facebook_ad',
Â  Â  Â  Â  Â  Â  redirect_type: 'manual_click',
Â  Â  Â  Â  Â  Â  internal_event_id: event_id,
Â  Â  Â  Â  Â  Â  internal_token: tokenHex
Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  fbq('track', 'Lead', pixelPayload, {
Â  Â  Â  Â  Â  Â  eventID: event_id,
Â  Â  Â  Â  Â  Â  eventSourceUrl: location.href,
Â  Â  Â  Â  Â  Â  eventSource: 'facebook_ads',
Â  Â  Â  Â  Â  Â  eventMedium: 'web_redirect_manual'
Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  console.log('ğŸ“Š Facebook Pixel disparado para redirecionamento manual:', pixelPayload);
Â  Â  Â  Â  }
Â  Â  Â  } catch (pixelError) {
Â  Â  Â  Â  console.error('âŒ Erro no Facebook Pixel manual:', pixelError);
Â  Â  Â  }
      */
Â  Â  Â Â 
Â  Â  Â  // Redireciona para WhatsApp com URL otimizada para desktop/mobile
Â  Â  Â  console.log('ğŸ”„ Redirecionando para WhatsApp (aÃ§Ã£o manual)...');
Â  Â  Â  const waUrl = createWhatsAppURL(mensagem);
Â  Â  Â  window.location.replace(waUrl);
Â  Â  }
Â  Â Â 
Â  Â  // Event listeners para clique e touch (APENAS UM por tipo)
Â  Â  document.addEventListener('click', redirectToWhatsApp);
Â  Â  document.addEventListener('touchstart', redirectToWhatsApp);

Â  Â  // ============== CONFIGURAÃ‡Ã•ES PRINCIPAIS ====================
Â  Â  // âš ï¸ ALTERE ESTAS CONFIGURAÃ‡Ã•ES CONFORME NECESSÃRIO âš ï¸
Â  Â Â 
Â  Â  // ğŸ’¡ NOVO SISTEMA DE TOKEN VISÃVEL:
Â  Â  // - Formato: "Cupom: {token}" (ex: "Cupom: a1b2c3d4")
Â  Â  // - Tamanho: 8 caracteres hexadecimais (0-9, a-f)
Â  Â  // - CombinaÃ§Ãµes Ãºnicas: 16^8 = 4.294.967.296 possibilidades
Â  Â  // - Vantagens: Simples, visÃ­vel, compatÃ­vel com WhatsApp
Â  Â  // - Exemplo de mensagem: "OlÃ¡! Quero receber os materiais! Cupom: a1b2c3d4"
Â  Â Â 
Â  Â  // ğŸ”´ META ADS PIXEL - ALTERE AQUI
Â  Â  const META_PIXEL_ID = '1242065550945306'; // Substitua pelo seu Pixel ID do Meta Ads
Â  Â Â 
Â  Â  // ğŸ“± WHATSAPP - ALTERE AQUI
Â  Â  const WHATSAPP_NUMBER = '5535991712235'; // Substitua pelo seu nÃºmero do WhatsApp
Â  Â  const BASE_MESSAGEÂ  Â  = 'OlÃ¡! Quero receber os materiais! Cupom: '; // Mensagem visÃ­vel para o usuÃ¡rio + prefixo do token
Â  Â Â 
Â  Â  // ğŸ”— WEBHOOK - ALTERE AQUI
Â  Â  const PREHOOK_URLÂ  Â  Â = 'https://webhook.servidorrrdigital.site/webhook/redirect'; // URL do seu webhook n8n
Â  Â Â 
Â  Â  // âš™ï¸ CONFIGURAÃ‡Ã•ES AVANÃ‡ADAS (altere apenas se necessÃ¡rio)
Â  Â  const REDIRECT_DELAYÂ  = 5000; // ms - delay antes do redirect automÃ¡tico
Â  Â  const DEDUPE_TTL_MSÂ  Â = 5 * 60 * 1000; // 5 min - tempo para evitar duplicatas
Â  Â  const WEBHOOK_RETRY_DELAY = 2000; // ms entre tentativas de webhook
Â  Â  const MAX_WEBHOOK_RETRIES = 5; // mÃ¡ximo de tentativas de webhook
Â  Â  const IP_TIMEOUT = 8000; // timeout para APIs de IP
Â  Â  const GEO_TIMEOUT = 10000; // timeout para APIs de geolocalizaÃ§Ã£o

Â  Â  Â  Â  Â // ============== HELPERS ===================
Â  Â  Â 
Â  Â  Â // Inicializa Facebook Pixel apÃ³s as configuraÃ§Ãµes serem definidas
Â  Â  Â if (typeof fbq !== 'undefined') {
Â  Â  Â  Â fbq('init', META_PIXEL_ID);
Â  Â  Â  Â fbq('track', 'PageView');
Â  Â  Â  Â console.log('âœ… Facebook Pixel inicializado com ID:', META_PIXEL_ID);
Â  Â  Â }
Â  Â  Â 
Â  Â  Â const qp = (n)=> new URLSearchParams(location.search).get(n);
Â  Â  function getCookie(k){
Â  Â  Â  const v = `; ${document.cookie}`.split(`; ${k}=`); return v.length === 2 ? v.pop().split(';').shift() : null;
Â  Â  }

    /**
     * âš ï¸ ALTERAÃ‡ÃƒO DE MELHORIA: Tenta obter o cookie _fbp com mÃºltiplas tentativas.
     * Isso aumenta a chance de coletar o cookie, contornando a "race condition"
     * onde o script tenta ler o cookie antes que o navegador o tenha criado.
     * @returns {Promise<string|null>} O valor do cookie _fbp ou null se nÃ£o for encontrado.
     */
    function getFbpWithRetry(retries = 4, delay = 200) {
      return new Promise(resolve => {
        let attempt = 1;

        function tryToGetCookie() {
          const fbpValue = getCookie('_fbp');
          if (fbpValue) {
            console.log(`âœ… _fbp coletado na tentativa ${attempt}:`, fbpValue);
            resolve(fbpValue);
          } else if (attempt < retries) {
            attempt++;
            console.log(`âš ï¸ _fbp nÃ£o encontrado. Tentando novamente em ${delay}ms... (Tentativa ${attempt})`);
            setTimeout(tryToGetCookie, delay);
          } else {
            console.error('âŒ _fbp nÃ£o foi coletado apÃ³s todas as tentativas.');
            resolve(null); // Retorna null se nÃ£o encontrar apÃ³s todas as tentativas
          }
        }
        tryToGetCookie();
      });
    }
Â  Â Â 
Â  Â  // FunÃ§Ã£o para criar URL do WhatsApp otimizada para desktop/mobile
Â  Â  function createWhatsAppURL(message) {
Â  Â  Â  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
Â  Â  Â  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
Â  Â  Â  const isAndroid = /Android/i.test(navigator.userAgent);
Â  Â  Â Â 
Â  Â  Â  console.log('ğŸ“± DetecÃ§Ã£o de dispositivo:', {
Â  Â  Â  Â  isMobile,
Â  Â  Â  Â  isIOS,
Â  Â  Â  Â  isAndroid,
Â  Â  Â  Â  userAgent: navigator.userAgent.substring(0, 100) + '...'
Â  Â  Â  });
Â  Â  Â Â 
Â  Â  Â  // Para dispositivos mÃ³veis, usa a API padrÃ£o do WhatsApp
Â  Â  Â  if (isMobile) {
Â  Â  Â  Â  const waUrl = `https://api.whatsapp.com/send?phone=${encodeURIComponent(WHATSAPP_NUMBER)}&text=${encodeURIComponent(message)}`;
Â  Â  Â  Â  console.log('ğŸ“± URL para mobile:', waUrl);
Â  Â  Â  Â  return waUrl;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Para desktop, usa estratÃ©gias diferentes para garantir que a mensagem apareÃ§a
Â  Â  Â  if (isIOS) {
Â  Â  Â  Â  // iOS desktop - tenta usar protocolo whatsapp://
Â  Â  Â  Â  const waUrl = `whatsapp://send?phone=${encodeURIComponent(WHATSAPP_NUMBER)}&text=${encodeURIComponent(message)}`;
Â  Â  Â  Â  console.log('ğŸ URL para iOS desktop:', waUrl);
Â  Â  Â  Â  return waUrl;
Â  Â  Â  } else if (isAndroid) {
Â  Â  Â  Â  // Android desktop - tenta usar protocolo whatsapp://
Â  Â  Â  Â  const waUrl = `whatsapp://send?phone=${encodeURIComponent(WHATSAPP_NUMBER)}&text=${encodeURIComponent(message)}`;
Â  Â  Â  Â  console.log('ğŸ¤– URL para Android desktop:', waUrl);
Â  Â  Â  Â  return waUrl;
Â  Â  Â  } else {
Â  Â  Â  Â  // Desktop Windows/Mac/Linux - usa mÃºltiplas estratÃ©gias
Â  Â  Â  Â  // Primeira tentativa: API web com parÃ¢metros otimizados
Â  Â  Â  Â  const waUrl = `https://api.whatsapp.com/send?phone=${encodeURIComponent(WHATSAPP_NUMBER)}&text=${encodeURIComponent(message)}&app_absent=0`;
Â  Â  Â  Â  console.log('ğŸ’» URL para desktop:', waUrl);
Â  Â  Â  Â  return waUrl;
Â  Â  Â  }
Â  Â  }
Â  Â  function uuidv4(){
Â  Â  Â  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,c=>{
Â  Â  Â  Â  const r = crypto.getRandomValues(new Uint8Array(1))[0] & 15;
Â  Â  Â  Â  const v = c === 'x' ? r : (r & 0x3 | 0x8);
Â  Â  Â  Â  return v.toString(16);
Â  Â  Â  });
Â  Â  }
Â  Â  function setDedupe(id){ try{ localStorage.setItem(`redir_sent_${id}`, String(Date.now())); }catch{} }
Â  Â  function isDedupe(id){
Â  Â  Â  try{
Â  Â  Â  Â  const t = Number(localStorage.getItem(`redir_sent_${id}`) || 0);
Â  Â  Â  Â  return t && (Date.now() - t) < DEDUPE_TTL_MS;
Â  Â  Â  }catch{}
Â  Â  Â  return false;
Â  Â  }
Â  Â  function slug(s){ return String(s||'na').toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,''); }

Â  Â  Â  Â  Â // --------- Sistema de Token por PosiÃ§Ã£o - MANTIDO PARA COMPATIBILIDADE ----------
Â  Â  Â // âš ï¸ DEPRECIADO: Sistema antigo mantido apenas para compatibilidade
Â  Â  Â // Usa apenas a POSIÃ‡ÃƒO dos caracteres invisÃ­veis, nÃ£o o conteÃºdo
Â  Â  Â // WhatsApp pode corromper o conteÃºdo, mas a POSIÃ‡ÃƒO permanece
Â  Â  Â function encodeHexAsPositional(hex) {
Â  Â  Â  Â // Mapeamento baseado em posiÃ§Ã£o - cada caractere em uma posiÃ§Ã£o especÃ­fica
Â  Â  Â  Â const POSITION_MAP = {
Â  Â  Â  Â  Â 0: '\u200B', 1: '\u200C', 2: '\u200D', 3: '\u2060',
Â  Â  Â  Â  Â 4: '\u2061', 5: '\u2062', 6: '\u2063', 7: '\u2064',
Â  Â  Â  Â  Â 8: '\u2065', 9: '\u2066', 10: '\u2067', 11: '\u2068',
Â  Â  Â  Â  Â 12: '\u2069', 13: '\u206A', 14: '\u206B', 15: '\u206C'
Â  Â  Â  Â };

Â  Â  Â  Â // Converte para string e garante 12 caracteres
Â  Â  Â  Â const hexStr = hex.toString().toLowerCase().padStart(12, '0');
Â  Â  Â  Â 
Â  Â  Â  Â // Cria token baseado em posiÃ§Ã£o: cada caractere em uma posiÃ§Ã£o especÃ­fica
Â  Â  Â  Â let positionalToken = '';
Â  Â  Â  Â for (let i = 0; i < hexStr.length; i++) {
Â  Â  Â  Â  Â const char = hexStr[i];
Â  Â  Â  Â  Â const position = parseInt(char, 16); // Converte hex para decimal (0-15)
Â  Â  Â  Â  Â const mapped = POSITION_MAP[position] || '\u200B'; // Fallback para posiÃ§Ã£o 0
Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â positionalToken += mapped;
Â  Â  Â  Â }
Â  Â  Â  Â 
Â  Â  Â  Â return positionalToken;
Â  Â  Â }

Â  Â  Â // FunÃ§Ã£o para criar mensagem com token posicional
Â  Â  Â function createMessageWithPositionalToken(baseMessage, tokenHex) {
Â  Â  Â  Â const positionalToken = encodeHexAsPositional(tokenHex);
Â  Â  Â  Â 
Â  Â  Â  Â // Token no final da mensagem
Â  Â  Â  Â return `${baseMessage}${positionalToken}`;
Â  Â  Â }

Â  Â  Â // --------- Zero-width encoder (hex -> invisÃ­vel) - MANTIDO PARA COMPATIBILIDADE ----------
Â  Â  Â // âš ï¸ DEPRECIADO: Sistema antigo mantido apenas para compatibilidade
Â  Â  Â // Sistema INVISÃVEL ULTRA-SEGURO - apenas caracteres que o WhatsApp NÃƒO detecta
Â  Â  Â // Usa APENAS os caracteres mais seguros e discretos para mÃ¡xima discriÃ§Ã£o
Â  Â  Â function encodeHexAsInvis(hex) {
Â  Â  Â  Â // Mapeamento ULTRA-SEGURO - apenas caracteres que passam despercebidos
Â  Â  Â  Â const MAP = {
Â  Â  Â  Â  Â '0': '\u200B', // Zero Width Space - mais discreto
Â  Â  Â  Â  Â '1': '\u200C', // Zero Width Non-Joiner
Â  Â  Â  Â  Â '2': '\u200D', // Zero Width Joiner
Â  Â  Â  Â  Â '3': '\u2060', // Word Joiner
Â  Â  Â  Â  Â '4': '\u2061', // Function Application
Â  Â  Â  Â  Â '5': '\u2062', // Invisible Times
Â  Â  Â  Â  Â '6': '\u2063', // Invisible Separator
Â  Â  Â  Â  Â '7': '\u2064', // Invisible Plus
Â  Â  Â  Â  Â '8': '\u2065', // Invisible Plus
Â  Â  Â  Â  Â '9': '\u2066', // Left-to-Right Isolate
Â  Â  Â  Â  Â 'a': '\u2067', // Right-to-Left Isolate
Â  Â  Â  Â  Â 'b': '\u2068', // First Strong Isolate
Â  Â  Â  Â  Â 'c': '\u2069', // Pop Directional Isolate
Â  Â  Â  Â  Â 'd': '\u206A', // Inhibit Symmetric Swapping
Â  Â  Â  Â  Â 'e': '\u206B', // Activate Symmetric Swapping
Â  Â  Â  Â  Â 'f': '\u206C'Â  // Inhibit Arabic Form Shaping
Â  Â  Â  Â };

Â  Â  Â  Â return hex
Â  Â  Â  Â  Â .toLowerCase()
Â  Â  Â  Â  Â .replace(/[^0-9a-f]/g, '')Â  // Remove caracteres invÃ¡lidos
Â  Â  Â  Â  Â .slice(0, 12)Â  Â  Â  Â  Â  Â  Â  Â // Garante exatamente 12 caracteres
Â  Â  Â  Â  Â .split('')
Â  Â  Â  Â  Â .map(char => MAP[char] || '')Â  // Mapeia APENAS caracteres vÃ¡lidos
Â  Â  Â  Â  Â .join('');
Â  Â  Â }

Â  Â  Â  Â  Â // FunÃ§Ã£o de teste para verificar compatibilidade
Â  Â  Â function testInvisibleToken() {
Â  Â  Â  Â const testHex = 'abc123def456';
Â  Â  Â  Â const invisibleToken = encodeHexAsInvis(testHex);
Â  Â  Â  Â const positionalToken = encodeHexAsPositional(testHex);
Â  Â  Â  Â const isAndroid = /Android/i.test(navigator.userAgent);
Â  Â  Â  Â const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
Â  Â  Â  Â const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
Â  Â  Â  Â 
Â  Â  Â  Â console.log('ğŸ§ª TESTE DE COMPATIBILIDADE DOS TOKENS:');
Â  Â  Â  Â console.log('ğŸ“± Plataforma detectada:', {
Â  Â  Â  Â  Â android: isAndroid,
Â  Â  Â  Â  Â ios: isIOS,
Â  Â  Â  Â  Â mobile: isMobile,
Â  Â  Â  Â  Â userAgent: navigator.userAgent.substring(0, 100) + '...'
Â  Â  Â  Â });
Â  Â  Â  Â console.log('ğŸ” Token original (hex):', testHex);
Â  Â  Â  Â console.log('ğŸ‘» Token invisÃ­vel (legado):', invisibleToken);
Â  Â  Â  Â console.log('ğŸ¯ Token posicional (novo):', positionalToken);
Â  Â  Â  Â console.log('ğŸ“ Comprimento dos tokens:', {
Â  Â  Â  Â  Â invisivel: invisibleToken.length,
Â  Â  Â  Â  Â posicional: positionalToken.length
Â  Â  Â  Â });
Â  Â  Â  Â console.log('âœ… Sistema hÃ­brido implementado!');
Â  Â  Â  Â console.log('ğŸ” Mapeamento POSICIONAL usado:', {
Â  Â  Â  Â  Â '0': '\\u200B (ZWSP)', '1': '\\u200C (ZWNJ)', '2': '\\u200D (ZWJ)', '3': '\\u2060 (WJ)',
Â  Â  Â  Â  Â '4': '\\u2061 (FX)', '5': '\\u2062 (INV TIMES)', '6': '\\u2063 (INV SEP)', '7': '\\u2064 (INV PLUS)',
Â  Â  Â  Â  Â '8': '\\u2065 (INV PLUS)', '9': '\\u2066 (LTR ISO)', '10': '\\u2067 (RTL ISO)', '11': '\\u2068 (FS ISO)',
Â  Â  Â  Â  Â '12': '\\u2069 (PD ISO)', '13': '\\u206A (ISS)', '14': '\\u206B (ASS)', '15': '\\u206C (IAFS)'
Â  Â  Â  Â });
Â  Â  Â  Â 
Â  Â  Â  Â // Teste do novo sistema de token visÃ­vel
Â  Â  Â  Â const newTokenHex = testHex.slice(0, 8);
Â  Â  Â  Â console.log('ğŸ†• NOVO SISTEMA DE TOKEN VISÃVEL:');
Â  Â  Â  Â console.log('ğŸ“ Formato da mensagem:', `${BASE_MESSAGE}${newTokenHex}`);
Â  Â  Â  Â console.log('ğŸ”¢ Token gerado:', newTokenHex);
Â  Â  Â  Â console.log('ğŸ“ Comprimento do token:', newTokenHex.length);
Â  Â  Â  Â console.log('ğŸ² CombinaÃ§Ãµes Ãºnicas possÃ­veis:', Math.pow(16, 8));
Â  Â  Â  Â console.log('ğŸ’¡ Exemplo de uso:', `"OlÃ¡! Quero receber os materiais! Ref. ${newTokenHex}"`);
Â  Â  Â }

Â  Â  // ============== IP & LOCATION HELPERS ======================
Â  Â  let userIP = 'unknown';
Â  Â  let userLocation = { country: 'BR', city: 'unknown', state: 'unknown' };
Â  Â  let ipDetectionComplete = false;

Â  Â  // MÃºltiplas APIs para captura de IP (fallback) - 8 APIs diferentes
Â  Â  const IP_APIS = [
Â  Â  Â  'https://api.ipify.org?format=json',
Â  Â  Â  'https://api64.ipify.org?format=json',
Â  Â  Â  'https://api.myip.com',
Â  Â  Â  'https://ipinfo.io/json',
Â  Â  Â  'https://httpbin.org/ip',
Â  Â  Â  'https://icanhazip.com',
Â  Â  Â  'https://checkip.amazonaws.com',
Â  Â  Â  'https://wtfismyip.com/json'
Â  Â  ];

Â  Â  // Tenta obter IP e localizaÃ§Ã£o real via mÃºltiplas APIs
Â  Â  async function getIPAndLocation() {
Â  Â  Â  console.log('ğŸ” Iniciando captura de IP...');
Â  Â  Â Â 
Â  Â  Â  // Array de promises para executar em paralelo
Â  Â  Â  const ipPromises = IP_APIS.map(async (apiUrl, index) => {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  console.log(`ğŸŒ Tentativa ${index + 1}: ${apiUrl}`);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // Cria um AbortController para timeout
Â  Â  Â  Â  Â  const controller = new AbortController();
Â  Â  Â  Â  Â  const timeoutId = setTimeout(() => controller.abort(), IP_TIMEOUT);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  const ipResponse = await fetch(apiUrl, {Â 
Â  Â  Â  Â  Â  Â  method: 'GET',
Â  Â  Â  Â  Â  Â  signal: controller.signal
Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  clearTimeout(timeoutId);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  if (ipResponse.ok) {
Â  Â  Â  Â  Â  Â  const ipData = await ipResponse.json();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Diferentes APIs retornam o IP em campos diferentes
Â  Â  Â  Â  Â  Â  const detectedIP = ipData.ip || ipData.ipAddress || ipData.query || ipData.ip_addr;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (detectedIP && detectedIP !== 'unknown') {
Â  Â  Â  Â  Â  Â  Â  console.log(`âœ… IP capturado via API ${index + 1}:`, detectedIP);
Â  Â  Â  Â  Â  Â  Â  return { ip: detectedIP, apiIndex: index };
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  if (error.name === 'AbortError') {
Â  Â  Â  Â  Â  Â  console.log(`â° Timeout na API ${index + 1}: ${apiUrl}`);
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  console.log(`âŒ Falha na API ${index + 1}:`, error.message);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return null;
Â  Â  Â  });

Â  Â  Â  // Aguarda todas as promises e pega o primeiro resultado vÃ¡lido
Â  Â  Â  const results = await Promise.allSettled(ipPromises);
Â  Â  Â  const validResult = results.find(result =>Â 
Â  Â  Â  Â  result.status === 'fulfilled' && result.value !== null
Â  Â  Â  );

Â  Â  Â  if (validResult && validResult.value) {
Â  Â  Â  Â  userIP = validResult.value.ip;
Â  Â  Â  Â  console.log('âœ… IP capturado com sucesso:', userIP);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Com o IP real, busca localizaÃ§Ã£o via mÃºltiplas APIs
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  await getLocationByIP(userIP);
Â  Â  Â  Â  } catch (geoError) {
Â  Â  Â  Â  Â  console.log('âš ï¸ Erro ao obter localizaÃ§Ã£o:', geoError.message);
Â  Â  Â  Â  }
Â  Â  Â  } else {
Â  Â  Â  Â  console.log('âš ï¸ Todas as APIs falharam na captura de IP');
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Usa dados do navegador como fallback
Â  Â  Â  Â  const browserData = getBrowserLocation();
Â  Â  Â  Â  userLocation = {
Â  Â  Â  Â  Â  ...userLocation,
Â  Â  Â  Â  Â  country: browserData.country,
Â  Â  Â  Â  Â  country_name: browserData.country_name,
Â  Â  Â  Â  Â  city: 'unknown', // NÃ£o conseguimos capturar cidade sem IP
Â  Â  Â  Â  Â  region: 'unknown', // NÃ£o conseguimos capturar estado sem IP
Â  Â  Â  Â  Â  state: 'unknown',
Â  Â  Â  Â  Â  postal_code: null // NÃ£o conseguimos capturar CEP sem IP
Â  Â  Â  Â  };
Â  Â  Â  Â  console.log('ğŸŒ Usando dados do navegador como fallback:', userLocation);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ipDetectionComplete = true;
Â  Â  Â Â 
Â  Â  Â  // Log final de todos os dados capturados
Â  Â  Â  console.log('ğŸ“Š RESUMO FINAL - Dados de localizaÃ§Ã£o capturados:', {
Â  Â  Â  Â  ip: userIP,
Â  Â  Â  Â  cidade: userLocation.city,
Â  Â  Â  Â  estado: userLocation.state,
Â  Â  Â  Â  pais: userLocation.country_name,
Â  Â  Â  Â  cep: userLocation.postal_code,
Â  Â  Â  Â  regiao: userLocation.region
Â  Â  Â  });
Â  Â  }

Â  Â  Â  Â  Â // FunÃ§Ã£o separada para obter localizaÃ§Ã£o por IP
Â  Â  Â async function getLocationByIP(ip) {
Â  Â  Â Â 
Â  Â  Â  // MÃºltiplas APIs de geolocalizaÃ§Ã£o para maior precisÃ£o (incluindo CEP)
Â  Â  Â  const GEO_APIS = [
Â  Â  Â  Â  `https://ipapi.co/${ip}/json/`,
Â  Â  Â  Â  `https://ip-api.com/json/${ip}`,
Â  Â  Â  Â  `https://freegeoip.app/json/${ip}`,
Â  Â  Â  Â  `https://extreme-ip-lookup.com/json/${ip}`,
Â  Â  Â  Â  `https://ipapi.com/${ip}/json/`,
Â  Â  Â  Â  `https://ipgeolocation.io/ipgeo?ip=${ip}`,
Â  Â  Â  Â  `https://ipinfo.io/${ip}/json`,
Â  Â  Â  Â  `https://api.ipgeolocation.io/ipgeo?apiKey=free&ip=${ip}`,
Â  Â  Â  Â  `https://api.ipstack.com/${ip}?access_key=free`
Â  Â  Â  ];
Â  Â  Â Â 
Â  Â  Â  let geoData = null;
Â  Â  Â Â 
Â  Â  Â  // Tenta cada API de geolocalizaÃ§Ã£o com retry
Â  Â  Â  for (let j = 0; j < GEO_APIS.length && !geoData; j++) {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  console.log(`ğŸŒ Tentativa de geolocalizaÃ§Ã£o: API ${j + 1} - ${GEO_APIS[j]}`);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // Cria um AbortController para timeout
Â  Â  Â  Â  Â  const controller = new AbortController();
Â  Â  Â  Â  Â  const timeoutId = setTimeout(() => controller.abort(), GEO_TIMEOUT);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  const geoResponse = await fetch(GEO_APIS[j], {Â 
Â  Â  Â  Â  Â  Â  method: 'GET',
Â  Â  Â  Â  Â  Â  signal: controller.signal
Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  clearTimeout(timeoutId);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  if (geoResponse.ok) {
Â  Â  Â  Â  Â  Â  geoData = await geoResponse.json();
Â  Â  Â  Â  Â  Â  console.log(`âœ… GeolocalizaÃ§Ã£o capturada via API ${j + 1}:`, geoData);
Â  Â  Â  Â  Â  Â  break; // Sai do loop se conseguiu
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  console.log(`âš ï¸ API ${j + 1} retornou status ${geoResponse.status}`);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  if (error.name === 'AbortError') {
Â  Â  Â  Â  Â  Â  console.log(`â° Timeout na API de geolocalizaÃ§Ã£o ${j + 1}`);
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  console.log(`âš ï¸ Falha na API ${j + 1}:`, error.message);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Processa dados de geolocalizaÃ§Ã£o de diferentes APIs
Â  Â  Â  if (geoData) {
Â  Â  Â  Â  // Diferentes APIs retornam dados em campos diferentes
Â  Â  Â  Â  userLocation = {
Â  Â  Â  Â  Â  country: geoData.country_code || geoData.country || 'BR',
Â  Â  Â  Â  Â  country_name: geoData.country_name || geoData.country || 'Brazil',
Â  Â  Â  Â  Â  city: geoData.city || geoData.regionName || geoData.locality || 'unknown',
Â  Â  Â  Â  Â  region: geoData.region || geoData.regionName || geoData.state || geoData.province || 'unknown',
Â  Â  Â  Â  Â  state: geoData.region || geoData.regionName || geoData.state || geoData.province || 'unknown',
Â  Â  Â  Â  Â  postal_code: geoData.postal || geoData.zip || geoData.postal_code || geoData.zipcode || null
Â  Â  Â  Â  };
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Log detalhado dos dados capturados
Â  Â  Â  Â  console.log('ğŸŒ LocalizaÃ§Ã£o real detectada via IP:', userLocation);
Â  Â  Â  Â  console.log('ğŸ“® CEP capturado:', userLocation.postal_code);
Â  Â  Â  Â  console.log('ğŸ™ï¸ Cidade capturada:', userLocation.city);
Â  Â  Â  Â  console.log('ğŸ›ï¸ Estado capturado:', userLocation.state);
Â  Â  Â  Â  console.log('ğŸŒ PaÃ­s capturado:', userLocation.country);
Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â // Log de sucesso da localizaÃ§Ã£o
Â  Â  Â  Â  Â const locationText = `${userLocation.city !== 'unknown' ? userLocation.city + ', ' : ''}${userLocation.state !== 'unknown' ? userLocation.state + ', ' : ''}${userLocation.country_name}`;
Â  Â  Â  Â  Â console.log('âœ… LocalizaÃ§Ã£o capturada com sucesso:', locationText);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Se nÃ£o capturou CEP, tenta buscar por cidade/estado
Â  Â  Â  Â  if (!userLocation.postal_code && userLocation.city !== 'unknown' && userLocation.state !== 'unknown') {
Â  Â  Â  Â  Â  console.log('ğŸ” CEP nÃ£o capturado, tentando buscar por cidade/estado...');
Â  Â  Â  Â  Â  const cepByCity = await lookupCEPByCity(userLocation.city, userLocation.state);
Â  Â  Â  Â  Â  if (cepByCity) {
Â  Â  Â  Â  Â  Â  userLocation.postal_code = cepByCity;
Â  Â  Â  Â  Â  Â  console.log('âœ… CEP encontrado por cidade/estado:', cepByCity);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  } else {
Â  Â  Â  Â  // Se todas as APIs falharam, tenta fallback
Â  Â  Â  Â  console.log('ğŸ”„ Todas as APIs falharam, tentando fallback...');
Â  Â  Â  Â  const fallbackLocation = await getLocationByIPFallback(ip);
Â  Â  Â  Â  if (fallbackLocation) {
Â  Â  Â  Â  Â  userLocation = fallbackLocation;
Â  Â  Â  Â  Â  console.log('âœ… LocalizaÃ§Ã£o capturada via fallback:', userLocation);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  console.log('âŒ Falha na captura de localizaÃ§Ã£o');
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }

Â  Â  // Inicia detecÃ§Ã£o de IP (nÃ£o bloqueia)
Â  Â  getIPAndLocation();
Â  Â Â 
Â  Â  // Testa compatibilidade do token invisÃ­vel
Â  Â  testInvisibleToken();
Â  Â Â 
Â  Â  // Retry automÃ¡tico se falhar na primeira tentativa
Â  Â  setTimeout(() => {
Â  Â  Â  if (!ipDetectionComplete || userIP === 'unknown') {
Â  Â  Â  Â  console.log('ğŸ”„ Tentando captura de localizaÃ§Ã£o novamente...');
Â  Â  Â  Â  getIPAndLocation();
Â  Â  Â  }
Â  Â  }, 8000); // tenta novamente em 8 segundos

Â  Â  // Retry adicional se ainda nÃ£o conseguiu
Â  Â  setTimeout(() => {
Â  Â  Â  if (!ipDetectionComplete || userIP === 'unknown') {
Â  Â  Â  Â  console.log('ğŸ”„ Tentativa final de captura de localizaÃ§Ã£o...');
Â  Â  Â  Â  getIPAndLocation();
Â  Â  Â  }
Â  Â  }, 15000); // tenta novamente em 15 segundos

Â  Â  // ============== IP LOCATION FALLBACK ======================
Â  Â  // Busca localizaÃ§Ã£o por IP usando API mais confiÃ¡vel
Â  Â  async function getLocationByIPFallback(ip) {
Â  Â  Â  try {
Â  Â  Â  Â  // Tenta API mais confiÃ¡vel para IPs brasileiros
Â  Â  Â  Â  const fallbackResponse = await fetch(`https://ipinfo.io/${ip}/json`, {
Â  Â  Â  Â  Â  method: 'GET',
Â  Â  Â  Â  Â  timeout: 5000
Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (fallbackResponse.ok) {
Â  Â  Â  Â  Â  const fallbackData = await fallbackResponse.json();
Â  Â  Â  Â  Â  console.log('ğŸ”„ Fallback IP location capturado:', fallbackData);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  if (fallbackData.city && fallbackData.region) {
Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  country: fallbackData.country || 'BR',
Â  Â  Â  Â  Â  Â  Â  country_name: 'Brazil',
Â  Â  Â  Â  Â  Â  Â  city: fallbackData.city,
Â  Â  Â  Â  Â  Â  Â  region: fallbackData.region,
Â  Â  Â  Â  Â  Â  Â  state: fallbackData.region,
Â  Â  Â  Â  Â  Â  Â  postal_code: fallbackData.postal || null
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  } catch (error) {
Â  Â  Â  Â  console.log('âš ï¸ Fallback IP location falhou:', error.message);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return null;
Â  Â  }
Â  Â Â 
Â  Â  // ============== CEP LOOKUP FALLBACK ======================
Â  Â  // Busca CEP por cidade/estado se nÃ£o foi capturado
Â  Â  async function lookupCEPByCity(city, state) {
Â  Â  Â  if (!city || city === 'unknown' || !state || state === 'unknown') {
Â  Â  Â  Â  return null;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  try {
Â  Â  Â  Â  // API do ViaCEP para buscar CEP por cidade/estado
Â  Â  Â  Â  const cepResponse = await fetch(`https://viacep.com.br/ws/${state}/${city}/json/`, {
Â  Â  Â  Â  Â  method: 'GET',
Â  Â  Â  Â  Â  timeout: 3000
Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (cepResponse.ok) {
Â  Â  Â  Â  Â  const cepData = await cepResponse.json();
Â  Â  Â  Â  Â  if (cepData && cepData.length > 0) {
Â  Â  Â  Â  Â  Â  // Retorna o primeiro CEP encontrado para a cidade
Â  Â  Â  Â  Â  Â  return cepData[0].cep;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  } catch (error) {
Â  Â  Â  Â  console.log('âš ï¸ Erro ao buscar CEP por cidade:', error.message);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return null;
Â  Â  }
Â  Â Â 
Â  Â  // ============== BROWSER LOCATION FALLBACK ======================
Â  Â  // Dados de localizaÃ§Ã£o do navegador (sem autorizaÃ§Ã£o)
Â  Â  function getBrowserLocation() {
Â  Â  Â  try {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  country: navigator.language.split('-')[1] || 'BR',
Â  Â  Â  Â  Â  country_name: new Intl.DisplayNames(['pt'], {type: 'region'}).of('BR') || 'Brazil',
Â  Â  Â  Â  Â  timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC',
Â  Â  Â  Â  Â  language: navigator.language || 'pt-BR'
Â  Â  Â  Â  };
Â  Â  Â  } catch (error) {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  country: 'BR',
Â  Â  Â  Â  Â  country_name: 'Brazil',
Â  Â  Â  Â  Â  timezone: 'UTC',
Â  Â  Â  Â  Â  language: 'pt-BR'
Â  Â  Â  Â  };
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  // ============== BROWSER & OS DETECTION ======================
Â  Â  function getBrowserInfo() {
Â  Â  Â  const ua = navigator.userAgent;
Â  Â  Â  if (ua.includes('Chrome')) return 'Chrome';
Â  Â  Â  if (ua.includes('Firefox')) return 'Firefox';
Â  Â  Â  if (ua.includes('Safari')) return 'Safari';
Â  Â  Â  if (ua.includes('Edge')) return 'Edge';
Â  Â  Â  if (ua.includes('Opera')) return 'Opera';
Â  Â  Â  return 'Unknown';
Â  Â  }

Â  Â  function getBrowserVersion() {
Â  Â  Â  const ua = navigator.userAgent;
Â  Â  Â  const browser = getBrowserInfo();
Â  Â  Â Â 
Â  Â  Â  if (browser === 'Chrome') {
Â  Â  Â  Â  const match = ua.match(/Chrome\/(\d+)/);
Â  Â  Â  Â  return match ? match[1] : 'Unknown';
Â  Â  Â  } else if (browser === 'Firefox') {
Â  Â  Â  Â  const match = ua.match(/Firefox\/(\d+)/);
Â  Â  Â  Â  return match ? match[1] : 'Unknown';
Â  Â  Â  } else if (browser === 'Safari') {
Â  Â  Â  Â  const match = ua.match(/Version\/(\d+)/);
Â  Â  Â  Â  return match ? match[1] : 'Unknown';
Â  Â  Â  } else if (browser === 'Edge') {
Â  Â  Â  Â  const match = ua.match(/Edge\/(\d+)/);
Â  Â  Â  Â  return match ? match[1] : 'Unknown';
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return 'Unknown';
Â  Â  }

Â  Â  function getOSInfo() {
Â  Â  Â  const ua = navigator.userAgent;
Â  Â  Â  if (ua.includes('Windows')) return 'Windows';
Â  Â  Â  if (ua.includes('Mac')) return 'macOS';
Â  Â  Â  if (ua.includes('Linux')) return 'Linux';
Â  Â  Â  if (ua.includes('Android')) return 'Android';
Â  Â  Â  if (ua.includes('iOS')) return 'iOS';
Â  Â  Â  return 'Unknown';
Â  Â  }

Â  Â  function getOSVersion() {
Â  Â  Â  const ua = navigator.userAgent;
Â  Â  Â Â 
Â  Â  Â  if (ua.includes('Windows')) {
Â  Â  Â  Â  if (ua.includes('Windows NT 10.0')) return '10.0';
Â  Â  Â  Â  if (ua.includes('Windows NT 6.3')) return '8.1';
Â  Â  Â  Â  if (ua.includes('Windows NT 6.2')) return '8.0';
Â  Â  Â  Â  if (ua.includes('Windows NT 6.1')) return '7.0';
Â  Â  Â  Â  return 'Unknown';
Â  Â  Â  } else if (ua.includes('Mac')) {
Â  Â  Â  Â  const match = ua.match(/Mac OS X (\d+_\d+)/);
Â  Â  Â  Â  return match ? match[1].replace('_', '.') : 'Unknown';
Â  Â  Â  } else if (ua.includes('Android')) {
Â  Â  Â  Â  const match = ua.match(/Android (\d+)/);
Â  Â  Â  Â  return match ? match[1] : 'Unknown';
Â  Â  Â  } else if (ua.includes('iOS')) {
Â  Â  Â  Â  const match = ua.match(/OS (\d+_\d+)/);
Â  Â  Â  Â  return match ? match[1].replace('_', '.') : 'Unknown';
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return 'Unknown';
Â  Â  }

Â  Â  function getDeviceModel() {
Â  Â  Â  const ua = navigator.userAgent;
Â  Â  Â Â 
Â  Â  Â  if (ua.includes('Mobile')) {
Â  Â  Â  Â  if (ua.includes('iPhone')) return 'iPhone';
Â  Â  Â  Â  if (ua.includes('iPad')) return 'iPad';
Â  Â  Â  Â  if (ua.includes('Android')) {
Â  Â  Â  Â  Â  // Tenta extrair modelo do Android
Â  Â  Â  Â  Â  const match = ua.match(/\(Linux.*?; (.*?) Build/);
Â  Â  Â  Â  Â  return match ? match[1] : 'Android Mobile';
Â  Â  Â  Â  }
Â  Â  Â  Â  return 'Mobile Device';
Â  Â  Â  } else if (ua.includes('Tablet')) {
Â  Â  Â  Â  return 'Tablet';
Â  Â  Â  } else {
Â  Â  Â  Â  return 'Desktop';
Â  Â  Â  }
Â  Â  }



Â  Â  // ============== MONITORING & DIAGNOSTICS ======================
Â  Â  let webhookStatus = {
Â  Â  Â  attempts: 0,
Â  Â  Â  success: false,
Â  Â  Â  lastAttempt: null,
Â  Â  Â  errors: [],
Â  Â  Â  startTime: Date.now()
Â  Â  };

Â  Â  // FunÃ§Ã£o para registrar mÃ©tricas de performance
Â  Â  function logPerformanceMetrics() {
Â  Â  Â  const endTime = Date.now();
Â  Â  Â  const totalTime = endTime - webhookStatus.startTime;
Â  Â  Â Â 
Â  Â  Â  console.log('ğŸ“Š MÃ‰TRICAS DE PERFORMANCE:', {
Â  Â  Â  Â  tempo_total_ms: totalTime,
Â  Â  Â  Â  tentativas_webhook: webhookStatus.attempts,
Â  Â  Â  Â  webhook_sucesso: webhookStatus.success,
Â  Â  Â  Â  ip_capturado: userIP !== 'unknown',
Â  Â  Â  Â  localizacao_capturada: userLocation.city !== 'unknown',
Â  Â  Â  Â  tempo_captura_ip: ipDetectionComplete ? 'completa' : 'em_andamento',
Â  Â  Â  Â  erros_encontrados: webhookStatus.errors.length
Â  Â  Â  });

Â  Â  Â  // Log de erros se houver
Â  Â  Â  if (webhookStatus.errors.length > 0) {
Â  Â  Â  Â  console.log('âš ï¸ ERROS ENCONTRADOS:', webhookStatus.errors);
Â  Â  Â  }
Â  Â  }

Â  Â  // FunÃ§Ã£o para registrar tentativas de webhook
Â  Â  function logWebhookAttempt(attempt, success, error = null) {
Â  Â  Â  webhookStatus.attempts = attempt;
Â  Â  Â  webhookStatus.lastAttempt = new Date().toISOString();
Â  Â  Â Â 
Â  Â  Â  if (error) {
Â  Â  Â  Â  webhookStatus.errors.push({
Â  Â  Â  Â  Â  attempt,
Â  Â  Â  Â  Â  error: error.message || error,
Â  Â  Â  Â  Â  timestamp: webhookStatus.lastAttempt
Â  Â  Â  Â  });
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  if (success) {
Â  Â  Â  Â  webhookStatus.success = true;
Â  Â  Â  }
Â  Â  }

Â  Â  // ============== WEBHOOK FUNCTIONS ======================
Â  Â  async function sendWebhook(payload, retryCount = 0) {
Â  Â  Â  try {
Â  Â  Â  Â  console.log(`ğŸ“¤ Tentativa ${retryCount + 1} de enviar webhook:`, {
Â  Â  Â  Â  Â  event_id: payload.event_id,
Â  Â  Â  Â  Â  ip: payload.ip || 'nÃ£o capturado',
Â  Â  Â  Â  Â  localizacao: payload.city || 'nÃ£o capturada'
Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Registra a tentativa
Â  Â  Â  Â  logWebhookAttempt(retryCount + 1, false);
Â  Â  Â  Â Â 
Â  Â  Â  Â  const response = await fetch(PREHOOK_URL, {
Â  Â  Â  Â  Â  method: 'POST',
Â  Â  Â  Â  Â  headers: {Â 
Â  Â  Â  Â  Â  Â  'Content-Type': 'application/json',
Â  Â  Â  Â  Â  Â  'Accept': 'application/json'
Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  body: JSON.stringify(payload)
Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (response.ok) {
Â  Â  Â  Â  Â  console.log('âœ… Webhook enviado com sucesso!', response.status);
Â  Â  Â  Â  Â  logWebhookAttempt(retryCount + 1, true);
Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  console.warn(`âš ï¸ Webhook falhou com status ${response.status}`);
Â  Â  Â  Â  Â  const errorText = await response.text();
Â  Â  Â  Â  Â  console.warn('Erro do servidor:', errorText);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // Registra o erro
Â  Â  Â  Â  Â  logWebhookAttempt(retryCount + 1, false, `HTTP ${response.status}: ${errorText}`);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  if (retryCount < MAX_WEBHOOK_RETRIES) {
Â  Â  Â  Â  Â  Â  console.log(`ğŸ”„ Tentando novamente em ${WEBHOOK_RETRY_DELAY}ms...`);
Â  Â  Â  Â  Â  Â  await new Promise(resolve => setTimeout(resolve, WEBHOOK_RETRY_DELAY));
Â  Â  Â  Â  Â  Â  return sendWebhook(payload, retryCount + 1);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  }
Â  Â  Â  } catch (error) {
Â  Â  Â  Â  console.error('âŒ Erro ao enviar webhook:', error);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Registra o erro
Â  Â  Â  Â  logWebhookAttempt(retryCount + 1, false, error.message || error);
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (retryCount < MAX_WEBHOOK_RETRIES) {
Â  Â  Â  Â  Â  console.log(`ğŸ”„ Tentando novamente em ${WEBHOOK_RETRY_DELAY}ms...`);
Â  Â  Â  Â  Â  await new Promise(resolve => setTimeout(resolve, WEBHOOK_RETRY_DELAY));
Â  Â  Â  Â  Â  return sendWebhook(payload, retryCount + 1);
Â  Â  Â  Â  }
Â  Â  Â  Â  return false;
Â  Â  Â  }
Â  Â  }

Â  Â  Â  Â  Â // FunÃ§Ã£o de fallback otimizada para evitar mÃºltiplas tentativas desnecessÃ¡rias
Â  Â  Â async function sendWebhookWithFallback(payload) {
Â  Â  Â  Â console.log('ğŸš€ Iniciando envio de webhook com sistema de fallback otimizado...');
Â  Â  Â Â 
Â  Â  Â  // Primeira tentativa com dados completos
Â  Â  Â  let success = await sendWebhook(payload);
Â  Â  Â Â 
Â  Â  Â  // Se falhou, tenta apenas UMA vez com dados mÃ­nimos
Â  Â  Â  if (!success) {
Â  Â  Â  Â  console.log('ğŸ”„ Primeira tentativa falhou, tentando com dados mÃ­nimos...');
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Cria payload mÃ­nimo com dados essenciais
Â  Â  Â  Â  const minimalPayload = {
Â  Â  Â  Â  Â  event_type: 'lead_captured',
Â  Â  Â  Â  Â  event_id: payload.event_id,
Â  Â  Â  Â  Â  short_token: payload.short_token,
Â  Â  Â  Â  Â  link_id: payload.link_id,
Â  Â  Â  Â  Â  phone_target: payload.phone_target,
Â  Â  Â  Â  Â  utm_source: payload.utm_source,
Â  Â  Â  Â  Â  utm_medium: payload.utm_medium,
Â  Â  Â  Â  Â  utm_campaign: payload.utm_campaign,
Â  Â  Â  Â  Â  url: payload.url,
Â  Â  Â  Â  Â  user_agent: payload.user_agent,
Â  Â  Â  Â  Â  language: payload.language,
Â  Â  Â  Â  Â  timezone: payload.timezone,
Â  Â  Â  Â  Â  client_timestamp: payload.client_timestamp,
Â  Â  Â  Â  Â  // Dados de fallback
Â  Â  Â  Â  Â  ip: 'capture_failed',
Â  Â  Â  Â  Â  city: 'capture_failed',
Â  Â  Â  Â  Â  region: 'capture_failed',
Â  Â  Â  Â  Â  country: 'BR',
Â  Â  Â  Â  Â  country_code: 'BR'
Â  Â  Â  Â  };
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Segunda tentativa com dados mÃ­nimos (ÃšLTIMA tentativa)
Â  Â  Â  Â  success = await sendWebhook(minimalPayload);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Log final do resultado
Â  Â  Â  if (success) {
Â  Â  Â  Â  console.log('ğŸ¯ Webhook enviado com sucesso apÃ³s fallback!');
Â  Â  Â  } else {
Â  Â  Â  Â  console.error('ğŸ’¥ Webhook falhou apÃ³s todas as tentativas!');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return success;
Â  Â  }

Â  Â  // ==== DECODER + CLASSIFIER (visÃ­vel ou frase gatilho) ====
Â  Â  // V.2.4 â€” limpa invisÃ­veis, normaliza texto, pega token visÃ­vel e classifica intenÃ§Ã£o
Â  Â  // ---------- Utils ----------
Â  Â  function stripZeroWidth(s) {
Â  Â  Â  return s.replace(/[\u200B-\u200D\u2060-\u206F\uFEFF\u00AD\u180E]/g, '');
Â  Â  }

Â  Â  function normalizeSpaces(s) {
Â  Â  Â  return s.replace(/\s+/g, ' ').trim();
Â  Â  }

Â  Â  function normalizeText(s) {
Â  Â  Â  // remove acentos e pÃµe minÃºsculas p/ comparaÃ§Ã£o robusta
Â  Â  Â  return s.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
Â  Â  }

Â  Â  // ---------- Token: visÃ­vel "Cupom: XXXXXXXX" + "Ref. XXXXXXXX" + fallback ----------
Â  Â  function decodeVisibleToken(text) {
Â  Â  Â  // NOVO FORMATO: "Cupom: XXXXXXXX"
Â  Â  Â  const cupomPattern = /Cupom:\s*([0-9a-fA-F]{8})/i;
Â  Â  Â  const cupomMatch = text.match(cupomPattern);
Â  Â  Â  if (cupomMatch) {
Â  Â  Â  Â  const tokenHex = cupomMatch[1].toLowerCase();
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  token_hex: tokenHex,
Â  Â  Â  Â  Â  reason: 'ok',
Â  Â  Â  Â  Â  scheme: 'visible_system_v2.4_cupom',
Â  Â  Â  Â  Â  pattern_matched: cupomMatch[0],
Â  Â  Â  Â  Â  position: {
Â  Â  Â  Â  Â  Â  start: cupomMatch.index,
Â  Â  Â  Â  Â  Â  end: cupomMatch.index + cupomMatch[0].length
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };
Â  Â  Â  }

Â  Â  Â  // FORMATO LEGADO: "Ref. XXXXXXXX" (mantido para compatibilidade)
Â  Â  Â  const refPattern = /Ref\.\s*([0-9a-fA-F]{8})/i;
Â  Â  Â  const refMatch = text.match(refPattern);
Â  Â  Â  if (refMatch) {
Â  Â  Â  Â  const tokenHex = refMatch[1].toLowerCase();
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  token_hex: tokenHex,
Â  Â  Â  Â  Â  reason: 'ok',
Â  Â  Â  Â  Â  scheme: 'visible_system_v2.4_ref_legacy',
Â  Â  Â  Â  Â  pattern_matched: refMatch[0],
Â  Â  Â  Â  Â  position: {
Â  Â  Â  Â  Â  Â  start: refMatch.index,
Â  Â  Â  Â  Â  Â  end: refMatch.index + refMatch[0].length
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };
Â  Â  Â  }

Â  Â  Â  // FALLBACK: busca por qualquer sequÃªncia de 8 caracteres hexadecimais
Â  Â  Â  const hexPattern = /([0-9a-fA-F]{8})/g;
Â  Â  Â  const hexMatches = text.match(hexPattern);
Â  Â  Â  if (hexMatches && hexMatches.length > 0) {
Â  Â  Â  Â  const tokenHex = hexMatches[0].toLowerCase();
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  token_hex: tokenHex,
Â  Â  Â  Â  Â  reason: 'fallback_pattern',
Â  Â  Â  Â  Â  scheme: 'visible_system_v2.4_fallback',
Â  Â  Â  Â  Â  total_matches: hexMatches.length,
Â  Â  Â  Â  Â  all_matches: hexMatches,
Â  Â  Â  Â  Â  warning: 'Token detectado por padrÃ£o hex, mas formato nÃ£o Ã© padrÃ£o'
Â  Â  Â  Â  };
Â  Â  Â  }

Â  Â  Â  // FALLBACK AVANÃ‡ADO: busca por sequÃªncias de 6-12 caracteres hex
Â  Â  Â  const flexibleHexPattern = /([0-9a-fA-F]{6,12})/g;
Â  Â  Â  const flexibleMatches = text.match(flexibleHexPattern);
Â  Â  Â  if (flexibleMatches && flexibleMatches.length > 0) {
Â  Â  Â  Â  const tokenHex = flexibleMatches[0].toLowerCase();
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  token_hex: tokenHex,
Â  Â  Â  Â  Â  reason: 'flexible_fallback',
Â  Â  Â  Â  Â  scheme: 'visible_system_v2.4_flexible',
Â  Â  Â  Â  Â  total_matches: flexibleMatches.length,
Â  Â  Â  Â  Â  all_matches: flexibleMatches,
Â  Â  Â  Â  Â  warning: `Token de ${tokenHex.length} caracteres detectado (formato flexÃ­vel)`,
Â  Â  Â  Â  Â  original_length: tokenHex.length
Â  Â  Â  Â  };
Â  Â  Â  }

Â  Â  Â  return {
Â  Â  Â  Â  token_hex: null,
Â  Â  Â  Â  reason: 'no_token_found',
Â  Â  Â  Â  scheme: 'visible_system_v2.4',
Â  Â  Â  Â  text_analyzed: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
Â  Â  Â  Â  text_length: text.length,
Â  Â  Â  Â  suggestions: [
Â  Â  Â  Â  Â  'Verificar se a mensagem contÃ©m "Cupom: XXXXXXXX"',
Â  Â  Â  Â  Â  'Verificar se a mensagem contÃ©m "Ref. XXXXXXXX"',
Â  Â  Â  Â  Â  'Verificar se hÃ¡ sequÃªncias de caracteres hexadecimais',
Â  Â  Â  Â  Â  'Verificar se o texto nÃ£o foi corrompido pelo WhatsApp'
Â  Â  Â  Â  ]
Â  Â  Â  };
Â  Â  }

Â  Â  // ---------- Classificador de IntenÃ§Ã£o ----------
Â  Â  function classifyIntent(text) {
Â  Â  Â  const normalized = normalizeText(text);
Â  Â  Â Â 
Â  Â  Â  // SaudaÃ§Ã£o
Â  Â  Â  if (/\b(oi|ola|olÃ¡|hey|ei|fala|opa|eai|e aÃ­)\b/.test(normalized)) {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  intent: 'saudacao',
Â  Â  Â  Â  Â  confidence: 0.9,
Â  Â  Â  Â  Â  keywords: ['oi', 'olÃ¡', 'hey', 'ei', 'fala', 'opa', 'eai'],
Â  Â  Â  Â  Â  response_type: 'greeting'
Â  Â  Â  Â  };
Â  Â  Â  }

Â  Â  Â  // Comprovante
Â  Â  Â  if (/\b(comprovante|recibo|nota|fiscal|boleto|pagamento|pago|paga)\b/.test(normalized)) {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  intent: 'comprovante',
Â  Â  Â  Â  Â  confidence: 0.85,
Â  Â  Â  Â  Â  keywords: ['comprovante', 'recibo', 'nota', 'fiscal', 'boleto', 'pagamento'],
Â  Â  Â  Â  Â  response_type: 'document_request'
Â  Â  Â  Â  };
Â  Â  Â  }

Â  Â  Â  // Ocupado
Â  Â  Â  if (/\b(ocupado|ocupada|indisponivel|indisponÃ­vel|nao|nÃ£o|negativo|n)\b/.test(normalized)) {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  intent: 'ocupado',
Â  Â  Â  Â  Â  confidence: 0.8,
Â  Â  Â  Â  Â  keywords: ['ocupado', 'indisponÃ­vel', 'nÃ£o', 'negativo'],
Â  Â  Â  Â  Â  response_type: 'unavailable'
Â  Â  Â  Â  };
Â  Â  Â  }

Â  Â  Â  // Material/Produto
Â  Â  Â  if (/\b(material|materiais|produto|produtos|receber|enviar|mandar|quero|gostaria|desejo)\b/.test(normalized)) {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  intent: 'material_request',
Â  Â  Â  Â  Â  confidence: 0.75,
Â  Â  Â  Â  Â  keywords: ['material', 'produto', 'receber', 'enviar', 'quero'],
Â  Â  Â  Â  Â  response_type: 'product_request'
Â  Â  Â  Â  };
Â  Â  Â  }

Â  Â  Â  // DÃºvida/InformaÃ§Ã£o
Â  Â  Â  if (/\b(duvida|dÃºvida|pergunta|como|quando|onde|quanto|preco|preÃ§o|valor|custo)\b/.test(normalized)) {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  intent: 'duvida',
Â  Â  Â  Â  Â  confidence: 0.7,
Â  Â  Â  Â  Â  keywords: ['dÃºvida', 'pergunta', 'como', 'quando', 'onde', 'preÃ§o'],
Â  Â  Â  Â  Â  response_type: 'information_request'
Â  Â  Â  Â  };
Â  Â  Â  }

Â  Â  Â  // Agradecimento
Â  Â  Â  if (/\b(obrigado|obrigada|valeu|valeu|agradeco|agradeÃ§o|grato|grata|thanks|thank)\b/.test(normalized)) {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  intent: 'agradecimento',
Â  Â  Â  Â  Â  confidence: 0.8,
Â  Â  Â  Â  Â  keywords: ['obrigado', 'valeu', 'agradeÃ§o', 'grato'],
Â  Â  Â  Â  Â  response_type: 'gratitude'
Â  Â  Â  Â  };
Â  Â  Â  }

Â  Â  Â  // Despedida
Â  Â  Â  if (/\b(tchau|ate|atÃ©|falou|flw|bye|adeus|ate logo|atÃ© logo)\b/.test(normalized)) {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  intent: 'despedida',
Â  Â  Â  Â  Â  confidence: 0.75,
Â  Â  Â  Â  Â  keywords: ['tchau', 'atÃ©', 'falou', 'bye', 'adeus'],
Â  Â  Â  Â  Â  response_type: 'farewell'
Â  Â  Â  Â  };
Â  Â  Â  }

Â  Â  Â  return {
Â  Â  Â  Â  intent: 'nao_identificado',
Â  Â  Â  Â  confidence: 0.1,
Â  Â  Â  Â  keywords: [],
Â  Â  Â  Â  response_type: 'unknown',
Â  Â  Â  Â  text_analyzed: normalized.substring(0, 50)
Â  Â  Â  };
Â  Â  }

Â  Â  // ---------- Decoder Principal ----------
Â  Â  function decodeMessage(text) {
Â  Â  Â  // Limpa o texto de caracteres invisÃ­veis
Â  Â  Â  const cleanText = stripZeroWidth(text);
Â  Â  Â  const normalizedText = normalizeSpaces(cleanText);
Â  Â  Â Â 
Â  Â  Â  // Decodifica o token
Â  Â  Â  const tokenResult = decodeVisibleToken(normalizedText);
Â  Â  Â Â 
Â  Â  Â  // Classifica a intenÃ§Ã£o
Â  Â  Â  const intentResult = classifyIntent(normalizedText);
Â  Â  Â Â 
Â  Â  Â  // Resultado completo
Â  Â  Â  return {
Â  Â  Â  Â  // Dados do token
Â  Â  Â  Â  token: tokenResult,
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Dados da intenÃ§Ã£o
Â  Â  Â  Â  intent: intentResult,
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Dados do texto original
Â  Â  Â  Â  text: {
Â  Â  Â  Â  Â  original: text,
Â  Â  Â  Â  Â  cleaned: cleanText,
Â  Â  Â  Â  Â  normalized: normalizedText,
Â  Â  Â  Â  Â  length: text.length,
Â  Â  Â  Â  Â  clean_length: cleanText.length
Â  Â  Â  Â  },
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Metadados
Â  Â  Â  Â  timestamp: new Date().toISOString(),
Â  Â  Â  Â  decoder_version: '2.4',
Â  Â  Â  Â  decoder_scheme: tokenResult.scheme || 'unknown',
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Status geral
Â  Â  Â  Â  success: tokenResult.token_hex !== null,
Â  Â  Â  Â  has_token: tokenResult.token_hex !== null,
Â  Â  Â  Â  has_intent: intentResult.intent !== 'nao_identificado',
Â  Â  Â  Â Â 
Â  Â  Â  Â  // RecomendaÃ§Ãµes
Â  Â  Â  Â  recommendations: []
Â  Â  Â  };
Â  Â  }

Â  Â  // ---------- FunÃ§Ã£o de Teste ----------
Â  Â  function testDecoder() {
Â  Â  Â  console.log('ğŸ§ª TESTANDO DECODER V2.4:');
Â  Â  Â Â 
Â  Â  Â  const testCases = [
Â  Â  Â  Â  'OlÃ¡! Quero receber os materiais! Cupom: a1b2c3d4',
Â  Â  Â  Â  'Oi, gostaria dos produtos Ref. e5f6g7h8',
Â  Â  Â  Â  'Quero o material Cupom: 12345678',
Â  Â  Â  Â  'Oi, tudo bem?',
Â  Â  Â  Â  'Preciso do comprovante',
Â  Â  Â  Â  'Estou ocupado agora',
Â  Â  Â  Â  'Obrigado pelos materiais!',
Â  Â  Â  Â  'Tchau, atÃ© mais!'
Â  Â  Â  ];
Â  Â  Â Â 
Â  Â  Â  testCases.forEach((testCase, index) => {
Â  Â  Â  Â  console.log(`\nğŸ“ Teste ${index + 1}: "${testCase}"`);
Â  Â  Â  Â  const result = decodeMessage(testCase);
Â  Â  Â  Â Â 
Â  Â  Â  Â  console.log('ğŸ” Token:', result.token);
Â  Â  Â  Â  console.log('ğŸ¯ IntenÃ§Ã£o:', result.intent);
Â  Â  Â  Â  console.log('âœ… Sucesso:', result.success);
Â  Â  Â  });
Â  Â  }

Â  Â  // Executa teste automÃ¡tico
Â  Â  testDecoder();

Â  Â  // ============== FLOW ======================
Â  Â  // Executa imediatamente para enviar webhook o quanto antes
Â  Â  // âš ï¸ IMPORTANTE: Esta funÃ§Ã£o executa apenas UMA vez por carregamento da pÃ¡gina
Â  Â  (async function(){
Â  Â  Â  console.log('ğŸš€ Iniciando execuÃ§Ã£o da funÃ§Ã£o principal IMEDIATAMENTE...');
Â  Â  Â Â 
Â  Â  Â  // UTMs
Â  Â  Â  const utm_sourceÂ  Â = slug(qp('utm_source')Â  Â || 'organic');
Â  Â  Â  const utm_mediumÂ  Â = slug(qp('utm_medium')Â  Â || 'direct');
Â  Â  Â  const utm_campaign = slug(qp('utm_campaign') || 'na');
Â  Â  Â  const utm_contentÂ  = slug(qp('utm_content')Â  || 'na');
Â  Â  Â  const utm_termÂ  Â  Â = slug(qp('utm_term')Â  Â  Â || 'na');

Â  Â  Â  // Meta cookies/params - CRÃTICOS para qualidade da correspondÃªncia
      // âš ï¸ ALTERAÃ‡ÃƒO DE MELHORIA: A coleta do _fbp agora usa a funÃ§Ã£o com retentativa.
Â  Â  Â  const fbpÂ  Â  = await getFbpWithRetry() || 'na';
Â  Â  Â  const fbclid = qp('fbclid');
Â  Â  Â  const fbcÂ  Â  = fbclid ? `fb.1.${Date.now()}.${fbclid}` : 'na';

Â  Â  Â  // IDs de vinculaÃ§Ã£o
Â  Â  Â  const event_id = uuidv4();Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // forte (server/CAPI)
Â  Â  Â  const tokenHex = event_id.replace(/-/g,'').slice(0,8); // 8 hex (0-9a-f) - menor tamanho
Â  Â  Â Â 
Â  Â  Â  // DEBUG DETALHADO DO TOKEN
Â  Â  Â  console.log('ğŸ” DEBUG COMPLETO DO TOKEN:', {
Â  Â  Â  Â  event_id_original: event_id,
Â  Â  Â  Â  token_hex_limpo: tokenHex,
Â  Â  Â  Â  token_visivel: tokenHex,
Â  Â  Â  Â  comprimento_total: tokenHex.length,
Â  Â  Â  Â  possiveis_combinacoes: Math.pow(16, 8), // 16^8 = 4.294.967.296 combinaÃ§Ãµes Ãºnicas
Â  Â  Â  Â  formato_mensagem: `${BASE_MESSAGE}${tokenHex}`
Â  Â  Â  });

Â  Â  Â  // Mensagem final: TOKEN VISÃVEL como "Cupom: {token}" - mais simples e compatÃ­vel
Â  Â  Â  const mensagem = `${BASE_MESSAGE}${tokenHex}`;

Â  Â  Â  // Dedupe client (evita repetir prehook no refresh)
Â  Â  Â  if (!isDedupe(event_id)) setDedupe(event_id);

Â  Â  Â  // FunÃ§Ã£o para preparar e enviar o webhook
Â  Â  Â  async function prepareAndSendWebhook() {
Â  Â  Â  Â  // Aguarda um pouco mais para a captura de IP (se ainda nÃ£o estiver completa)
Â  Â  Â  Â  if (!ipDetectionComplete) {
Â  Â  Â  Â  Â  console.log('â³ Aguardando captura de IP...');
Â  Â  Â  Â  Â  await new Promise(resolve => setTimeout(resolve, 2000));
Â  Â  Â  Â  }

Â  Â  Â  Â  // Dispara prehook -> n8n -> Supabase (salva clique)
Â  Â  Â  Â  const payload = {
Â  Â  Â  Â  Â  event_type: 'lead_captured',
Â  Â  Â  Â  Â  event_id,
Â  Â  Â  Â  Â  short_token: tokenHex,Â  Â  Â  Â  Â  Â  Â  Â // para cruzar no inbound
Â  Â  Â  Â  Â  link_id: `${utm_source}_${utm_medium}_${utm_campaign}`, // ID Ãºnico do link
Â  Â  Â  Â  Â  phone_target: WHATSAPP_NUMBER,
Â  Â  Â  Â  Â  // UTMs individuais para facilitar queries
Â  Â  Â  Â  Â  utm_source,
Â  Â  Â  Â  Â  utm_medium,
Â  Â  Â  Â  Â  utm_campaign,
Â  Â  Â  Â  Â  utm_content,
Â  Â  Â  Â  Â  utm_term,
Â  Â  Â  Â  Â  // IDs de campanha (usando UTMs quando disponÃ­veis)
Â  Â  Â  Â  Â  ad_id: utm_content !== 'na' ? utm_content : null,
Â  Â  Â  Â  Â  adset_id: utm_campaign !== 'na' ? utm_campaign : null,
Â  Â  Â  Â  Â  campaign_id: utm_campaign !== 'na' ? utm_campaign : null,
Â  Â  Â  Â  Â  // Dados de contexto
Â  Â  Â  Â  Â  url: location.href,
Â  Â  Â  Â  Â  referrer: document.referrer || null,
Â  Â  Â  Â  Â  user_agent: navigator.userAgent,
Â  Â  Â  Â  Â  language: navigator.language || 'pt-BR',
Â  Â  Â  Â  Â  timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC',
Â  Â  Â  Â  Â  screen: `${screen?.width || 0}x${screen?.height || 0}`,
Â  Â  Â  Â  Â  // InformaÃ§Ãµes de dispositivo
Â  Â  Â  Â  Â  device_model: getDeviceModel(),
Â  Â  Â  Â  Â  browser_name: getBrowserInfo(),
Â  Â  Â  Â  Â  browser_version: getBrowserVersion(),
Â  Â  Â  Â  Â  os_name: getOSInfo(),
Â  Â  Â  Â  Â  os_version: getOSVersion(),
Â  Â  Â  Â  Â  // IP e localizaÃ§Ã£o
Â  Â  Â  Â  Â  ip: userIP !== 'unknown' ? userIP : null,
Â  Â  Â  Â  Â  city: userLocation.city !== 'unknown' ? userLocation.city : null,
Â  Â  Â  Â  Â  region: userLocation.region !== 'unknown' ? userLocation.region : null,
Â  Â  Â  Â  Â  country: userLocation.country_name !== 'unknown' ? userLocation.country_name : null,
Â  Â  Â  Â  Â  country_code: userLocation.country !== 'unknown' ? userLocation.country : null,
Â  Â  Â  Â  Â  // Meta cookies/params
Â  Â  Â  Â  Â  fbp: fbp !== 'na' ? fbp : null,
Â  Â  Â  Â  Â  fbc: fbc !== 'na' ? fbc : null,
Â  Â  Â  Â  Â  fbclid: fbclid || null,
Â  Â  Â  Â  Â  // Timestamp
Â  Â  Â  Â  Â  client_timestamp: new Date().toISOString()
Â  Â  Â  Â  };

Â  Â  Â  Â  // Log para verificar os valores gerados
Â  Â  Â  Â  console.log('ğŸ” DEBUG - Valores gerados:', {
Â  Â  Â  Â  Â  event_id,
Â  Â  Â  Â  Â  short_token: tokenHex,
Â  Â  Â  Â  Â  link_id: `${utm_source}_${utm_medium}_${utm_campaign}`,
Â  Â  Â  Â  Â  utm_source,
Â  Â  Â  Â  Â  utm_medium,
Â  Â  Â  Â  Â  utm_campaign,
Â  Â  Â  Â  Â  ip_capturado: userIP,
Â  Â  Â  Â  Â  localizacao: userLocation
Â  Â  Â  Â  });

Â  Â  Â  Â  // Log do payload completo que serÃ¡ enviado
Â  Â  Â  Â  console.log('ğŸ“¤ Payload completo para webhook:', {
Â  Â  Â  Â  Â  ip: userIP !== 'unknown' ? userIP : 'nÃ£o capturado',
Â  Â  Â  Â  Â  localizacao: userLocation,
Â  Â  Â  Â  Â  event_id,
Â  Â  Â  Â  Â  short_token: tokenHex,
Â  Â  Â  Â  Â  link_id: `${utm_source}_${utm_medium}_${utm_campaign}`
Â  Â  Â  Â  });

Â  Â  Â  Â  // Tenta enviar webhook com fallback robusto
Â  Â  Â  Â  const success = await sendWebhookWithFallback(payload);
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (success) {
Â  Â  Â  Â  Â  console.log('ğŸ¯ Lead capturado e enviado para n8n com sucesso!');
Â  Â  Â  Â  Â  console.log('ğŸ“¡ IP enviado no webhook:', userIP !== 'unknown' ? userIP : 'nÃ£o capturado');
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  console.error('ğŸ’¥ Falha ao enviar lead para n8n apÃ³s todas as tentativas');
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  return success;
Â  Â  Â  }

Â  Â  Â  // ============== FACEBOOK PIXEL MAXIMIZADO ======================
Â  Â  Â  // Pixel com MÃXIMO de parÃ¢metros para QUALIDADE SUPERIOR da correspondÃªncia
Â  Â  Â  try {Â 
Â  Â  Â  Â  if (fbq) {
Â  Â  Â  Â  Â  // Payload COMPLETO com todos os dados disponÃ­veis para mÃ¡xima qualidade
Â  Â  Â  Â  Â  const pixelPayload = {
Â  Â  Â  Â  Â  Â  // Dados bÃ¡sicos do evento
Â  Â  Â  Â  Â  Â  value: 0,
Â  Â  Â  Â  Â  Â  currency: 'BRL',
Â  Â  Â  Â  Â  Â  content_name: 'WhatsApp Lead',
Â  Â  Â  Â  Â  Â  content_category: 'Lead Generation',
Â  Â  Â  Â  Â  Â  content_type: 'product',
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // PARÃ‚METROS CRÃTICOS para qualidade da correspondÃªncia:
Â  Â  Â  Â  Â  Â  fbc: fbc !== 'na' ? fbc : undefined,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Facebook Click ID
Â  Â  Â  Â  Â  Â  fbp: fbp !== 'na' ? fbp : undefined,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Facebook Browser ID
Â  Â  Â  Â  Â  Â  user_agent: navigator.userAgent,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // User Agent completo
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Dados de localizaÃ§Ã£o GEOGRÃFICA (mÃ¡xima precisÃ£o)
Â  Â  Â  Â  Â  Â  ip_address: userIP !== 'unknown' ? userIP : undefined,
Â  Â  Â  Â  Â  Â  country: userLocation.country !== 'unknown' ? userLocation.country : undefined,
Â  Â  Â  Â  Â  Â  country_name: userLocation.country_name !== 'unknown' ? userLocation.country_name : undefined,
Â  Â  Â  Â  Â  Â  city: userLocation.city !== 'unknown' ? userLocation.city : undefined,
Â  Â  Â  Â  Â  Â  state: userLocation.state !== 'unknown' ? userLocation.state : undefined,
Â  Â  Â  Â  Â  Â  region: userLocation.region !== 'unknown' ? userLocation.region : undefined,
Â  Â  Â  Â  Â  Â  postal_code: userLocation.postal_code || undefined,
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // ParÃ¢metros UTM COMPLETOS (vÃªm da URL do anÃºncio)
Â  Â  Â  Â  Â  Â  utm_source: utm_source !== 'organic' ? utm_source : undefined,
Â  Â  Â  Â  Â  Â  utm_medium: utm_medium !== 'direct' ? utm_medium : undefined,
Â  Â  Â  Â  Â  Â  utm_campaign: utm_campaign !== 'na' ? utm_campaign : undefined,
Â  Â  Â  Â  Â  Â  utm_content: utm_content !== 'na' ? utm_content : undefined,
Â  Â  Â  Â  Â  Â  utm_term: utm_term !== 'na' ? utm_term : undefined,
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // IDs de campanha do Meta Ads
Â  Â  Â  Â  Â  Â  campaign_id: utm_campaign !== 'na' ? utm_campaign : undefined,
Â  Â  Â  Â  Â  Â  ad_id: utm_content !== 'na' ? utm_content : undefined,
Â  Â  Â  Â  Â  Â  adset_id: utm_campaign !== 'na' ? utm_campaign : undefined,
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Dados de contexto da pÃ¡gina
Â  Â  Â  Â  Â  Â  page_title: document.title,
Â  Â  Â  Â  Â  Â  page_url: location.href,
Â  Â  Â  Â  Â  Â  referrer: document.referrer || undefined,
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Dados de dispositivo e navegador
Â  Â  Â  Â  Â  Â  device_type: getDeviceModel(),
Â  Â  Â  Â  Â  Â  browser_name: getBrowserInfo(),
Â  Â  Â  Â  Â  Â  browser_version: getBrowserVersion(),
Â  Â  Â  Â  Â  Â  os_name: getOSInfo(),
Â  Â  Â  Â  Â  Â  os_version: getOSVersion(),
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Dados de tela e viewport
Â  Â  Â  Â  Â  Â  screen_width: screen?.width || undefined,
Â  Â  Â  Â  Â  Â  screen_height: screen?.height || undefined,
Â  Â  Â  Â  Â  Â  viewport_width: window.innerWidth || undefined,
Â  Â  Â  Â  Â  Â  viewport_height: window.innerHeight || undefined,
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Dados de idioma e fuso horÃ¡rio
Â  Â  Â  Â  Â  Â  language: navigator.language || 'pt-BR',
Â  Â  Â  Â  Â  Â  timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC',
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Dados de performance
Â  Â  Â  Â  Â  Â  page_load_time: Date.now() - webhookStatus.startTime,
Â  Â  Â  Â  Â  Â  connection_type: navigator.connection?.effectiveType || undefined,
Â  Â  Â  Â  Â  Â  connection_speed: navigator.connection?.downlink || undefined,
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Dados de contexto do lead
Â  Â  Â  Â  Â  Â  lead_type: 'whatsapp_redirect',
Â  Â  Â  Â  Â  Â  lead_source: 'facebook_ad',
Â  Â  Â  Â  Â  Â  lead_medium: utm_medium !== 'direct' ? utm_medium : 'organic',
Â  Â  Â  Â  Â  Â  lead_campaign: utm_campaign !== 'na' ? utm_campaign : 'direct',
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Dados de rastreamento interno
Â  Â  Â  Â  Â  Â  internal_event_id: event_id,
Â  Â  Â  Â  Â  Â  internal_token: tokenHex,
Â  Â  Â  Â  Â  Â  internal_link_id: `${utm_source}_${utm_medium}_${utm_campaign}`,
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Dados de contexto do anÃºncio
Â  Â  Â  Â  Â  Â  ad_placement: 'facebook_feed',
Â  Â  Â  Â  Â  Â  ad_format: 'single_image',
Â  Â  Â  Â  Â  Â  ad_objective: 'lead_generation',
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Dados de comportamento
Â  Â  Â  Â  Â  Â  user_engagement: 'high',
Â  Â  Â  Â  Â  Â  conversion_intent: 'immediate',
Â  Â  Â  Â  Â  Â  lead_quality: 'hot'
Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  // Remove campos undefined para nÃ£o enviar dados vazios
Â  Â  Â  Â  Â  Object.keys(pixelPayload).forEach(key => {
Â  Â  Â  Â  Â  Â  if (pixelPayload[key] === undefined) {
Â  Â  Â  Â  Â  Â  Â  delete pixelPayload[key];
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  // Dispara evento com MÃXIMO de dados para qualidade superior
Â  Â  Â  Â  Â  fbq('track', 'Lead', pixelPayload, {
Â  Â  Â  Â  Â  Â  eventID: event_id,Â  Â  Â  Â  Â  Â // Dedupe por eventID
Â  Â  Â  Â  Â  Â  eventSourceUrl: location.href,
Â  Â  Â  Â  Â  Â  // ParÃ¢metros adicionais de contexto
Â  Â  Â  Â  Â  Â  eventSource: 'facebook_ads',
Â  Â  Â  Â  Â  Â  eventMedium: 'web_redirect',
Â  Â  Â  Â  Â  Â  eventCampaign: utm_campaign !== 'na' ? utm_campaign : 'organic'
Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // Log detalhado para debug
Â  Â  Â  Â  Â  console.log('ğŸ“Š Facebook Pixel MAXIMIZADO disparado:', {
Â  Â  Â  Â  Â  Â  total_params: Object.keys(pixelPayload).length,
Â  Â  Â  Â  Â  Â  critical_params: {
Â  Â  Â  Â  Â  Â  Â  fbc: fbc !== 'na' ? fbc : 'nÃ£o disponÃ­vel',Â 
Â  Â  Â  Â  Â  Â  Â  fbp: fbp !== 'na' ? fbp : 'nÃ£o disponÃ­vel',Â 
Â  Â  Â  Â  Â  Â  Â  ip: userIP !== 'unknown' ? userIP : 'nÃ£o detectado',
Â  Â  Â  Â  Â  Â  Â  location: userLocation.country !== 'unknown' ? userLocation : 'nÃ£o detectada'
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  utm_params: {Â 
Â  Â  Â  Â  Â  Â  Â  source: utm_source,Â 
Â  Â  Â  Â  Â  Â  Â  medium: utm_medium,Â 
Â  Â  Â  Â  Â  Â  Â  campaign: utm_campaign,Â 
Â  Â  Â  Â  Â  Â  Â  content: utm_content,Â 
Â  Â  Â  Â  Â  Â  Â  term: utm_termÂ 
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  device_params: {
Â  Â  Â  Â  Â  Â  Â  device: getDeviceModel(),
Â  Â  Â  Â  Â  Â  Â  browser: getBrowserInfo(),
Â  Â  Â  Â  Â  Â  Â  os: getOSInfo(),
Â  Â  Â  Â  Â  Â  Â  screen: `${screen?.width || 0}x${screen?.height || 0}`
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  performance_params: {
Â  Â  Â  Â  Â  Â  Â  load_time: Date.now() - webhookStatus.startTime,
Â  Â  Â  Â  Â  Â  Â  connection: navigator.connection?.effectiveType || 'unknown'
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // Log do payload completo para verificaÃ§Ã£o
Â  Â  Â  Â  Â  console.log('ğŸ¯ Payload completo do Pixel:', pixelPayload);
Â  Â  Â  Â  }
Â  Â  Â  } catch (error) {
Â  Â  Â  Â  console.error('âŒ Erro no Facebook Pixel:', error);
Â  Â  Â  }

Â  Â  Â  // ============== LÃ“GICA DE REDIRECT AUTOMÃTICO COM AGUARDO DO WEBHOOK ======================
Â  Â  Â  console.log('ğŸ”„ Iniciando processo de webhook e aguardando resultado...');
Â  Â  Â Â 
Â  Â  Â  // Tenta enviar o webhook e aguarda o resultado
Â  Â  Â  let webhookSuccess = false;
Â  Â  Â  const webhookStartTime = Date.now();
Â  Â  Â Â 
Â  Â  Â  try {
Â  Â  Â  Â  webhookSuccess = await prepareAndSendWebhook();
Â  Â  Â  } catch (error) {
Â  Â  Â  Â  console.error('âŒ Erro crÃ­tico ao enviar webhook:', error);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Se o webhook foi enviado com sucesso, redireciona automaticamente
Â  Â  Â  if (webhookSuccess) {
Â  Â  Â  Â  console.log('âœ… Webhook enviado com sucesso! Redirecionando automaticamente para WhatsApp...');
Â  Â  Â  Â  redirectInProgress = true; // Marca como em progresso para evitar conflito
Â  Â  Â  Â  const waUrl = createWhatsAppURL(mensagem);
Â  Â  Â  Â  window.location.replace(waUrl);
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Se o webhook falhou, aguarda atÃ© 5 segundos antes de redirecionar automaticamente (REDUZIDO)
Â  Â  Â  const elapsedTime = Date.now() - webhookStartTime;
Â  Â  Â  const remainingTime = Math.max(0, 5000 - elapsedTime); // Reduzido de 10s para 5s
Â  Â  Â Â 
Â  Â  Â  if (remainingTime > 0) {
Â  Â  Â  Â  console.log(`â³ Webhook falhou. Aguardando ${remainingTime}ms antes de redirecionar automaticamente...`);
Â  Â  Â  Â Â 
Â  Â  Â  Â  await new Promise(resolve => setTimeout(resolve, remainingTime));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // ApÃ³s 5 segundos ou se o webhook falhou, redireciona automaticamente
Â  Â  Â  console.log('ğŸ”„ Redirecionando automaticamente para WhatsApp apÃ³s timeout...');
Â  Â  Â  redirectInProgress = true; // Marca como em progresso para evitar conflito
Â  Â  Â  const waUrl = createWhatsAppURL(mensagem);
Â  Â  Â  window.location.replace(waUrl);
Â  Â  Â Â 
Â  Â  })();

Â  Â  // Monitor de performance que roda a cada 2 segundos
Â  Â  const performanceMonitor = setInterval(() => {
Â  Â  Â  if (ipDetectionComplete && webhookStatus.lastAttempt) {
Â  Â  Â  Â  clearInterval(performanceMonitor);
Â  Â  Â  Â  logPerformanceMetrics();
Â  Â  Â  }
Â  Â  }, 2000);

Â  Â  // Monitor de performance final apÃ³s 10 segundos (REDUZIDO para casos de falha total)
Â  Â  setTimeout(() => {
Â  Â  Â  if (performanceMonitor) {
Â  Â  Â  Â  clearInterval(performanceMonitor);
Â  Â  Â  Â  logPerformanceMetrics();
Â  Â  Â  }
Â  Â  }, 10000); // Reduzido de 15s para 10s
Â  </script>
</body>
</html>
